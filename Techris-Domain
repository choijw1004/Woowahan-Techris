Object subclass: #TetrisBoard	instanceVariableNames: 'width height cells'	classVariableNames: ''	package: 'Techris-Core'!TetrisBoard class	instanceVariableNames: ''!Object subclass: #TetrisGame	instanceVariableNames: 'board currentTetromino nextTetromino score linesCleared gameOver'	classVariableNames: ''	package: 'Techris-Core'!TetrisGame class	instanceVariableNames: ''!Object subclass: #TetrominoType	instanceVariableNames: 'name rotations'	classVariableNames: ''	package: 'Techris-Core'!TetrominoType class	instanceVariableNames: ''!Object subclass: #Tetromino	instanceVariableNames: 'type rotationIndex row col'	classVariableNames: ''	package: 'Techris-Core'!Tetromino class	instanceVariableNames: 'row'!!TetrisBoard class methodsFor: 'instance creation' stamp: '2025-11-24T20:16:56.127928+09:00' prior: 0!standard    ^ self width: 12 height: 20! !!TetrisBoard class methodsFor: 'instance creation' stamp: '2025-11-24T20:16:56.128286+09:00' prior: 0!width: w height: h    ^ self new        width: w;        height: h;        initializeCells;        yourself! !!TetrisBoard methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.129256+09:00' prior: 0!atRow: aRow col: aCol    ^ (cells at: aRow) at: aCol! !!TetrisBoard methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.129568+09:00' prior: 0!atRow: aRow col: aCol put: aValue    (cells at: aRow) at: aCol put: aValue.    ^ aValue! !!TetrisBoard methodsFor: 'testing' stamp: '2025-11-24T20:16:56.129657+09:00' prior: 0!clearFullLines    | newRows cleared |    newRows := OrderedCollection new.    cleared := 0.    1 to: height do: [:row |        (self isRowFull: row)            ifTrue: [cleared := cleared + 1]            ifFalse: [newRows add: (cells at: row)]].    cleared = 0 ifTrue: [^ 0].	 1 to: cleared do: [:i |        newRows addFirst: (Array new: width withAll: 0)    ].    cells := newRows asArray.    ^ cleared! !!TetrisBoard methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.129719+09:00' prior: 0!height    ^ height! !!TetrisBoard methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.129806+09:00' prior: 0!height: anInteger    height := anInteger! !!TetrisBoard methodsFor: 'initialization' stamp: '2025-11-24T20:16:56.129855+09:00' prior: 0!initializeCells    cells := Array new: height.    1 to: height do: [:row |        cells at: row put: (Array new: width withAll: 0)].! !!TetrisBoard methodsFor: 'testing' stamp: '2025-11-24T20:16:56.129904+09:00' prior: 0!isEmptyRow: aRow col: aCol    ^ (self atRow: aRow col: aCol) = 0! !!TetrisBoard methodsFor: 'testing' stamp: '2025-11-24T20:16:56.129942+09:00' prior: 0!isInsideRow: aRow col: aCol    ^ (aRow between: 1 and: height)        and: (aCol between: 1 and: width)! !!TetrisBoard methodsFor: 'testing' stamp: '2025-11-24T20:16:56.129981+09:00' prior: 0!isRowFull: aRow    ^ (1 to: width) allSatisfy: [:col |        (self atRow: aRow col: col) ~= 0 ]! !!TetrisBoard methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.130017+09:00' prior: 0!width    ^ width! !!TetrisBoard methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.130086+09:00' prior: 0!width: anInteger    width := anInteger! !!TetrisGame class methodsFor: 'initialization' stamp: '2025-11-24T20:16:56.130129+09:00' prior: 0!newStandard    ^ self new initializeStandard! !!TetrisGame methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.130158+09:00' prior: 0!board    ^ board! !!TetrisGame methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.130206+09:00' prior: 0!canPlaceTetromino: aTetromino    ^ aTetromino cells allSatisfy: [:pt |        (board isInsideRow: pt y col: pt x)            and: [board isEmptyRow: pt y col: pt x] ]! !!TetrisGame methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.130256+09:00' prior: 0!currentTetromino    ^ currentTetromino! !!TetrisGame methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.130297+09:00' prior: 0!gameOver    ^ gameOver ifNil: [ false ]! !!TetrisGame methodsFor: 'as yet unclassified' stamp: '2025-11-24T20:16:56.13059+09:00' prior: 0!ghostTetromino    | ghost |    currentTetromino ifNil: [ ^ nil ].        ghost := currentTetromino.        [        | moved |        moved := ghost movedDown.        (self canPlaceTetromino: moved)            ifTrue: [ ghost := moved. true ]            ifFalse: [ false ]    ] whileTrue.        ^ ghost! !!TetrisGame methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.130648+09:00' prior: 0!handleFullLines    | cleared |    cleared := board clearFullLines.    cleared > 0 ifTrue: [        self updateScoreForClearedLines: cleared.        linesCleared := linesCleared + cleared ].    ^ cleared! !!TetrisGame methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.130706+09:00' prior: 0!hardDrop    gameOver ifTrue: [ ^ self ].    [        | moved |        moved := currentTetromino movedDown.        (self canPlaceTetromino: moved)            ifTrue: [ currentTetromino := moved. true ]            ifFalse: [ self lockCurrentTetromino. false ]    ] whileTrue.! !!TetrisGame methodsFor: 'initialization' stamp: '2025-11-24T20:16:56.130748+09:00' prior: 0!initializeStandard    board := TetrisBoard standard.    score := 0.    linesCleared := 0.    gameOver := false.    self spawnInitialTetrominos.    ^ self! !!TetrisGame methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.130917+09:00' prior: 0!lockCurrentTetromino    currentTetromino cells do: [:pt |        board atRow: pt y col: pt x put: currentTetromino type name ].  "<-- 타입 저장"    self handleFullLines.    currentTetromino := nextTetromino.    nextTetromino := self newRandomTetrominoAtTop.    (self canPlaceTetromino: currentTetromino)        ifFalse: [ gameOver := true ].! !!TetrisGame methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.130999+09:00' prior: 0!moveLeft    | moved |    gameOver ifTrue: [ ^ self ].    moved := currentTetromino movedLeft.    (self canPlaceTetromino: moved)        ifTrue: [ currentTetromino := moved ].! !!TetrisGame methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.131055+09:00' prior: 0!moveRight    | moved |    gameOver ifTrue: [ ^ self ].    moved := currentTetromino movedRight.    (self canPlaceTetromino: moved)        ifTrue: [ currentTetromino := moved ].! !!TetrisGame methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.131093+09:00' prior: 0!newRandomTetrominoAtTop    | type startCol |    type := TetrominoType random.    startCol := board width // 2.    ^ Tetromino ofType: type atRow: 1 col: startCol! !!TetrisGame methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.131132+09:00' prior: 0!nextTetromino    ^ nextTetromino! !!TetrisGame methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.131172+09:00' prior: 0!rotate	 | rotated |    gameOver ifTrue: [ ^ self ].    rotated := currentTetromino rotatedRight.    (self canPlaceTetromino: rotated)        ifTrue: [ currentTetromino := rotated ].! !!TetrisGame methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.131213+09:00' prior: 0!score    ^ score ifNil: [ 0 ]! !!TetrisGame methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.13125+09:00' prior: 0!softDrop    gameOver ifTrue: [ ^ self ].    self stepDown! !!TetrisGame methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.131285+09:00' prior: 0!spawnInitialTetrominos    currentTetromino := self newRandomTetrominoAtTop.    nextTetromino := self newRandomTetrominoAtTop! !!TetrisGame methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.13133+09:00' prior: 0!stepDown    | moved |    moved := currentTetromino movedDown.    (self canPlaceTetromino: moved)        ifTrue: [ currentTetromino := moved ]        ifFalse: [ self lockCurrentTetromino ].! !!TetrisGame methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.13137+09:00' prior: 0!tick    gameOver ifTrue: [ ^ self ].    self stepDown! !!TetrisGame methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.131419+09:00' prior: 0!updateScoreForClearedLines: aCount    aCount = 1 ifTrue: [ score := score + 100. ^ score ].    aCount = 2 ifTrue: [ score := score + 300. ^ score ].    aCount = 3 ifTrue: [ score := score + 500. ^ score ].    aCount = 4 ifTrue: [ score := score + 800. ^ score ].    score := score + (aCount * 100).    ^ score! !!Tetromino class methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.131468+09:00' prior: 0!ofType: aType atRow: r col: c    | t |    t := self new.    t        type: aType;        rotationIndex: 0;        row: r;        col: c.    ^ t! !!Tetromino methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.1315+09:00' prior: 0!cells    | rel |    rel := type cellsForRotationIndex: rotationIndex.    ^ rel collect: [:pt |        (col + pt x) @ (row + pt y)      ]! !!Tetromino methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.131537+09:00' prior: 0!col    ^ col! !!Tetromino methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.131576+09:00' prior: 0!col: anInteger    col := anInteger! !!Tetromino methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.131613+09:00' prior: 0!color    ^ type color! !!Tetromino methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.13165+09:00' prior: 0!movedByRow: dRow col: dCol    | t |    t := self copy.    t        row: row + dRow;        col: col + dCol.    ^ t! !!Tetromino methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.131692+09:00' prior: 0!movedDown    ^ self movedByRow: 1 col: 0! !!Tetromino methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.131733+09:00' prior: 0!movedLeft    ^ self movedByRow: 0 col: -1! !!Tetromino methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.131766+09:00' prior: 0!movedRight    ^ self movedByRow: 0 col: 1! !!Tetromino methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.131808+09:00' prior: 0!rotatedLeft	 | t newIndex |    t := self copy.    newIndex := (rotationIndex - 1) \\ type rotationCount.    t rotationIndex: newIndex.    ^ t! !!Tetromino methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.131846+09:00' prior: 0!rotatedRight    | t newIndex |    t := self copy.    newIndex := (rotationIndex + 1) \\ type rotationCount.    t rotationIndex: newIndex.    ^ t! !!Tetromino methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.13188+09:00' prior: 0!rotationIndex    ^ rotationIndex! !!Tetromino methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.131912+09:00' prior: 0!rotationIndex: anInteger    rotationIndex := anInteger! !!Tetromino methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.13195+09:00' prior: 0!row    ^ row! !!Tetromino methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.131987+09:00' prior: 0!row: anInteger    row := anInteger! !!Tetromino methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.132023+09:00' prior: 0!type    ^ type! !!Tetromino methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.132121+09:00' prior: 0!type: aTetrominoType    type := aTetrominoType! !!TetrominoType class methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.132153+09:00' prior: 0!allTypes    ^ { self i. self o. self t. self s. self z. self j. self l }! !!TetrominoType class methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.132183+09:00' prior: 0!i    | type |    type := self new.    type        name: #I;        rotations: {            { 0@0. 1@0. 2@0. 3@0 }.            { 1@ -1. 1@0. 1@1. 1@2 }.            { 0@1. 1@1. 2@1. 3@1 }.            { 2@ -1. 2@0. 2@1. 2@2 }        }.    ^ type! !!TetrominoType class methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.132215+09:00' prior: 0!j    | type |    type := self new.    type        name: #J;        rotations: {            { 0@0. 0@1. 1@1. 2@1 }.            { 1@0. 2@0. 1@1. 1@2 }.            { 0@1. 1@1. 2@1. 2@2 }.            { 1@0. 1@1. 0@2. 1@2 }        }.    ^ type! !!TetrominoType class methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.132246+09:00' prior: 0!l    | type |    type := self new.    type        name: #L;        rotations: {            { 2@0. 0@1. 1@1. 2@1 }.            { 1@0. 1@1. 1@2. 2@2 }.            { 0@1. 1@1. 2@1. 0@2 }.            { 0@0. 1@0. 1@1. 1@2 }        }.    ^ type! !!TetrominoType class methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.132273+09:00' prior: 0!o    | type |    type := self new.    type        name: #O;        rotations: {            { 0@0. 1@0. 0@1. 1@1 }        }.    ^ type! !!TetrominoType class methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.132301+09:00' prior: 0!random    ^ self allTypes atRandom! !!TetrominoType class methodsFor: 'path commands' stamp: '2025-11-24T20:16:56.132329+09:00' prior: 0!s    | type |    type := self new.    type        name: #S;        rotations: {            { 1@0. 2@0. 0@1. 1@1 }.            { 1@0. 1@1. 2@1. 2@2 }.            { 1@1. 2@1. 0@2. 1@2 }.            { 0@0. 0@1. 1@1. 1@2 }        }.    ^ type! !!TetrominoType class methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.132361+09:00' prior: 0!t    | type |    type := self new.    type        name: #T;        rotations: {            { 1@0. 0@1. 1@1. 2@1 }.            { 1@0. 1@1. 2@1. 1@2 }.            { 0@1. 1@1. 2@1. 1@2 }.            { 1@0. 0@1. 1@1. 1@2 }        }.    ^ type! !!TetrominoType class methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.132392+09:00' prior: 0!z    | type |    type := self new.    type        name: #Z;        rotations: {            { 0@0. 1@0. 1@1. 2@1 }.            { 2@0. 1@1. 2@1. 1@2 }.            { 0@1. 1@1. 1@2. 2@2 }.            { 1@0. 0@1. 1@1. 0@2 }        }.    ^ type! !!TetrominoType methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.13242+09:00' prior: 0!cellsForRotationIndex: anIndex    ^ rotations at: (anIndex + 1) ! !!TetrominoType methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.132468+09:00' prior: 0!color    name = #I ifTrue: [ ^ Color cyan ].    name = #O ifTrue: [ ^ Color yellow ].    name = #T ifTrue: [ ^ Color magenta ].    name = #S ifTrue: [ ^ Color green ].    name = #Z ifTrue: [ ^ Color red ].    name = #J ifTrue: [ ^ Color blue ].    name = #L ifTrue: [ ^ Color orange ].    ^ Color green! !!TetrominoType methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.132509+09:00' prior: 0!name    ^ name! !!TetrominoType methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.132548+09:00' prior: 0!name: aSymbol    name := aSymbol! !!TetrominoType methodsFor: 'defaults' stamp: '2025-11-24T20:16:56.13258+09:00' prior: 0!rotationCount    ^ rotations size! !!TetrominoType methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.132616+09:00' prior: 0!rotations    ^ rotations! !!TetrominoType methodsFor: 'accessing' stamp: '2025-11-24T20:16:56.132647+09:00' prior: 0!rotations: aCollection    rotations := aCollection! !